#!/usr/bin/env python3
"""
cask - Send message to Codex via Gateway API.

Designed to be used with Claude Code's run_in_background=true.
If --output is provided, the reply is written atomically to that file and stdout stays empty.
"""

from __future__ import annotations

import json
import os
import sys
from pathlib import Path
from typing import Optional, Tuple

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))

from compat import read_stdin_text, setup_windows_encoding

setup_windows_encoding()

from cli_output import EXIT_ERROR, EXIT_OK, atomic_write_text
from gateway_client import gateway_ask_codex


SUPERVISOR_PROMPT = """## Executor Mode: codex+opencode
You are the SUPERVISOR, NOT the executor.
- Do NOT directly edit repo files yourself.
- Break down tasks into clear instructions for OpenCode.
- Use oask to delegate execution to OpenCode.
- Review OpenCode results and iterate if needed.

"""

COLLABORATOR_PROMPT = """## Collaboration Mode
You can execute tasks directly AND collaborate with other AIs when needed.

Available collaboration commands:
- gask: Ask Gemini (web search, large code analysis)
- oask: Ask OpenCode (code execution)
- iask: Ask iFlow
- kask: Ask Kimi
- qask: Ask Qwen

Guidelines:
- Execute simple tasks directly yourself
- For complex tasks, you may discuss with other AIs
- Use gask for web searches or when you need external information
- Use oask for code execution if you prefer delegation
- Return final results to Claude

"""


def _get_executor_from_roles() -> Tuple[Optional[str], bool]:
    """Read executor and collaboration setting from roles config."""
    candidates = [
        Path(".autoflow/roles.session.json"),
        Path(".autoflow/roles.json"),
        Path.home() / ".config" / "cca" / "roles.json",
    ]
    xdg_config = (os.environ.get("XDG_CONFIG_HOME") or "").strip()
    if xdg_config:
        candidates.append(Path(xdg_config) / "cca" / "roles.json")
    if os.name == "nt":
        appdata = (os.environ.get("APPDATA") or "").strip()
        if appdata:
            candidates.append(Path(appdata) / "cca" / "roles.json")
        localappdata = (os.environ.get("LOCALAPPDATA") or "").strip()
        if localappdata:
            candidates.append(Path(localappdata) / "cca" / "roles.json")
    for cfg_path in candidates:
        if cfg_path.exists():
            try:
                data = json.loads(cfg_path.read_text(encoding="utf-8"))
                executor = data.get("executor")
                collaboration = data.get("collaboration", False)
                if executor:
                    return executor, collaboration
            except Exception:
                pass
    return None, False


def _usage() -> None:
    print("Usage: cask [--timeout SECONDS] [--output FILE] <message>", file=sys.stderr)


def _parse_args(argv: list[str]) -> Tuple[Optional[Path], float, str, bool]:
    output: Optional[Path] = None
    timeout: Optional[float] = None
    quiet = False
    parts: list[str] = []

    it = iter(argv[1:])
    for token in it:
        if token in ("-h", "--help"):
            _usage()
            raise SystemExit(0)
        if token in ("-q", "--quiet"):
            quiet = True
            continue
        if token in ("-o", "--output"):
            try:
                output = Path(next(it)).expanduser()
            except StopIteration:
                raise ValueError("--output requires a file path")
            continue
        if token in ("-t", "--timeout"):
            try:
                timeout = float(next(it))
            except StopIteration:
                raise ValueError("--timeout requires a number")
            except ValueError as exc:
                raise ValueError(f"Invalid --timeout: {exc}")
            continue
        parts.append(token)

    message = " ".join(parts).strip()
    if timeout is None:
        try:
            timeout = float(os.environ.get("CCB_SYNC_TIMEOUT", "300"))
        except Exception:
            timeout = 300.0
    return output, timeout, message, quiet


def main(argv: list[str]) -> int:
    try:
        output_path, timeout, message, quiet = _parse_args(argv)
        if not message and not sys.stdin.isatty():
            message = read_stdin_text().strip()
        if not message:
            _usage()
            return EXIT_ERROR

        # Check if supervisor mode or collaboration mode is enabled via roles config
        executor, collaboration = _get_executor_from_roles()
        if executor == "codex+opencode":
            message = SUPERVISOR_PROMPT + message
        elif collaboration:
            message = COLLABORATOR_PROMPT + message

        # Use Gateway API
        reply, exit_code = gateway_ask_codex(message, timeout_s=timeout if timeout > 0 else 300.0, wait=True)
        if reply:
            if output_path:
                atomic_write_text(output_path, reply + "\n")
                return exit_code
            sys.stdout.write(reply)
            if not reply.endswith("\n"):
                sys.stdout.write("\n")
        return exit_code

    except KeyboardInterrupt:
        return 130
    except Exception as exc:
        print(f"[ERROR] {exc}", file=sys.stderr)
        return EXIT_ERROR


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
