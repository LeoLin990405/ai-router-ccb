#!/usr/bin/env python3
"""
ccb-ask - Intelligent routing CLI for CCB

Routes messages to the optimal AI provider based on task type,
file patterns, and keywords.

Usage:
    ccb-ask <message>           # Auto-route to best provider
    ccb-ask -p gemini <message> # Force specific provider
    ccb-ask --route <message>   # Show routing decision only
    ccb-ask --health            # Check provider health
    ccb-ask --track <message>   # Track task with ID
    ccb-ask --magic             # List magic keywords
"""
from __future__ import annotations

import sys
import os
import argparse
import subprocess
import time
from pathlib import Path
from typing import Optional

# Add lib to path
script_dir = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(script_dir / "lib"))

from unified_router import UnifiedRouter, ChannelType, ProviderStatus, ProviderHealth
from task_tracker import TaskTracker, TaskStatus
from performance_tracker import PerformanceTracker
from response_cache import ResponseCache
from retry_policy import RetryExecutor, RetryConfig, RetryAttempt
from multi_provider import MultiProviderExecutor, AggregationStrategy, format_multi_result


# Create global instances
_router = UnifiedRouter()
_perf_tracker: Optional[PerformanceTracker] = None
_cache: Optional[ResponseCache] = None


def get_perf_tracker() -> PerformanceTracker:
    """Get or create performance tracker instance."""
    global _perf_tracker
    if _perf_tracker is None:
        _perf_tracker = PerformanceTracker()
    return _perf_tracker


def get_cache() -> ResponseCache:
    """Get or create response cache instance."""
    global _cache
    if _cache is None:
        _cache = ResponseCache()
    return _cache


def get_ask_command(provider: str) -> str:
    """Get the ask command for a provider."""
    return _router.get_provider_command(provider)


def get_ping_command(provider: str) -> str:
    """Get the ping command for a provider."""
    return _router.get_provider_ping_command(provider)


def check_daemon_health(provider: str) -> ProviderHealth:
    """Check if a provider's daemon is healthy."""
    ping_cmd = get_ping_command(provider)
    if not ping_cmd:
        return ProviderHealth(
            provider=provider,
            status=ProviderStatus.UNKNOWN,
            error="Unknown provider",
        )

    start_time = time.time()
    try:
        result = subprocess.run(
            [ping_cmd],
            capture_output=True,
            text=True,
            timeout=5,
        )
        latency = (time.time() - start_time) * 1000

        if result.returncode == 0:
            return ProviderHealth(
                provider=provider,
                status=ProviderStatus.HEALTHY,
                latency_ms=latency,
                last_check=time.time(),
            )
        else:
            return ProviderHealth(
                provider=provider,
                status=ProviderStatus.UNAVAILABLE,
                latency_ms=latency,
                last_check=time.time(),
                error=result.stderr.strip() if result.stderr else "Ping failed",
            )
    except subprocess.TimeoutExpired:
        return ProviderHealth(
            provider=provider,
            status=ProviderStatus.DEGRADED,
            last_check=time.time(),
            error="Timeout",
        )
    except FileNotFoundError:
        return ProviderHealth(
            provider=provider,
            status=ProviderStatus.UNAVAILABLE,
            last_check=time.time(),
            error=f"Command '{ping_cmd}' not found",
        )
    except Exception as e:
        return ProviderHealth(
            provider=provider,
            status=ProviderStatus.UNAVAILABLE,
            last_check=time.time(),
            error=str(e),
        )


def execute_ask(provider: str, message: str, use_daemon: bool = True,
                tracker: Optional[TaskTracker] = None, task_id: Optional[str] = None,
                record_perf: bool = True, cache_response: bool = False) -> int:
    """Execute the ask command for a provider.

    Args:
        provider: Provider name
        message: Message to send
        use_daemon: Whether to use daemon
        tracker: Task tracker instance
        task_id: Task ID for tracking
        record_perf: Whether to record performance metrics
        cache_response: Whether to cache the response
    """
    ask_cmd = get_ask_command(provider)

    # Update task status to running if tracking
    if tracker and task_id:
        tracker.update_status(task_id, TaskStatus.RUNNING)

    # Record start time for performance tracking
    start_time = time.time()
    success = False
    error_msg = None
    response_text = None

    if use_daemon:
        # Use heredoc style for daemon
        cmd = f"{ask_cmd} <<'EOF'\n{message}\nEOF"

        # Capture output if caching is enabled
        if cache_response:
            result = subprocess.run(
                ["bash", "-c", cmd],
                capture_output=True,
                text=True,
            )
            response_text = result.stdout
            # Print the output
            if response_text:
                print(response_text, end='')
            if result.stderr:
                print(result.stderr, end='', file=sys.stderr)
        else:
            result = subprocess.run(
                ["bash", "-c", cmd],
                capture_output=False,
            )

        success = result.returncode == 0

        # Update task status based on result
        if tracker and task_id:
            if success:
                tracker.update_status(task_id, TaskStatus.COMPLETED)
            else:
                error_msg = f"Exit code: {result.returncode}"
                tracker.update_status(task_id, TaskStatus.FAILED, error=error_msg)

        # Record performance metric
        if record_perf:
            latency_ms = (time.time() - start_time) * 1000
            perf_tracker = get_perf_tracker()
            perf_tracker.record(
                provider=provider,
                latency_ms=latency_ms,
                success=success,
                task_id=task_id,
                error=error_msg,
            )

        # Cache successful response
        if cache_response and success and response_text:
            cache = get_cache()
            cache.set(message, provider, response_text)

        return result.returncode
    else:
        # Direct CLI fallback (provider-specific)
        print(f"[Fallback] Direct CLI not implemented for {provider}")
        error_msg = "Direct CLI not implemented"
        if tracker and task_id:
            tracker.update_status(task_id, TaskStatus.FAILED, error=error_msg)

        # Record failed attempt
        if record_perf:
            latency_ms = (time.time() - start_time) * 1000
            perf_tracker = get_perf_tracker()
            perf_tracker.record(
                provider=provider,
                latency_ms=latency_ms,
                success=False,
                task_id=task_id,
                error=error_msg,
            )

        return 1


def cmd_route(args: argparse.Namespace) -> int:
    """Show routing decision without executing."""
    router = UnifiedRouter()
    message = " ".join(args.message)

    decision = router.route(
        message=message,
        files=args.files,
        preferred_provider=args.provider,
    )

    print("=" * 50)
    print("Routing Decision")
    print("=" * 50)
    print(router.format_decision(decision))
    print("=" * 50)
    print(f"Command: {get_ask_command(decision.provider)}")

    return 0


def cmd_health(args: argparse.Namespace) -> int:
    """Check health of all providers."""
    # Use the router's ALL_PROVIDERS list
    providers = UnifiedRouter.ALL_PROVIDERS

    print("=" * 60)
    print("Provider Health Status")
    print("=" * 60)
    print(f"{'Provider':<12} {'Status':<12} {'Latency':<10} {'Error'}")
    print("-" * 60)

    for provider in providers:
        health = check_daemon_health(provider)
        status_icon = {
            ProviderStatus.HEALTHY: "✓",
            ProviderStatus.DEGRADED: "~",
            ProviderStatus.UNAVAILABLE: "✗",
            ProviderStatus.UNKNOWN: "?",
        }.get(health.status, "?")

        latency_str = f"{health.latency_ms:.0f}ms" if health.latency_ms else "-"
        error_str = health.error or ""

        print(f"{provider:<12} {status_icon} {health.status.value:<10} {latency_str:<10} {error_str}")

    print("=" * 60)
    return 0


def cmd_magic(args: argparse.Namespace) -> int:
    """List available magic keywords."""
    router = UnifiedRouter()
    keywords = router.list_magic_keywords()

    print("=" * 70)
    print("Magic Keywords")
    print("=" * 70)
    print(f"{'Keyword':<12} {'Action':<18} {'Provider':<12} {'Description'}")
    print("-" * 70)

    for kw in keywords:
        keyword = kw.get("keyword", "")
        action = kw.get("action", "")
        provider = kw.get("provider", kw.get("providers", [""])[0] if kw.get("providers") else "")
        description = kw.get("description", "")

        print(f"{keyword:<12} {action:<18} {provider:<12} {description}")

    print("=" * 70)
    print("\nUsage: Include magic keyword in your message to trigger special behavior.")
    print("Example: ccb ask '@deep analyze this algorithm'")
    return 0


def cmd_ask(args: argparse.Namespace) -> int:
    """Route and execute ask command."""
    router = UnifiedRouter()
    message = " ".join(args.message)

    if not message.strip():
        print("Error: No message provided", file=sys.stderr)
        return 1

    # Check for @all keyword - use multi-provider execution
    if "@all" in message.lower() or args.multi:
        return cmd_multi_provider(args, message, router)

    decision = router.route(
        message=message,
        files=args.files,
        preferred_provider=args.provider,
    )

    # Show routing decision if verbose
    if args.verbose:
        print(f"[Router] {decision.reason}")
        print(f"[Router] Using: {decision.provider} via {decision.channel.value}")

    # Check cache first (if enabled)
    if args.cache:
        cache = get_cache()
        cached_response = cache.get(message, decision.provider)
        if cached_response:
            if args.verbose:
                print("[Cache] Hit - returning cached response")
            print(cached_response)
            return 0

    # Check daemon health
    health = check_daemon_health(decision.provider)

    use_daemon = True
    if health.status == ProviderStatus.UNAVAILABLE:
        if decision.fallback:
            print(f"[Router] Daemon unavailable, using fallback: {decision.fallback.value}")
            use_daemon = False
        else:
            print(f"Error: Provider {decision.provider} is unavailable", file=sys.stderr)
            return 1

    # Task tracking
    tracker = None
    task_id = None
    if args.track:
        tracker = TaskTracker()
        task = tracker.create_task(
            provider=decision.provider,
            message=message,
            metadata={"files": args.files, "reason": decision.reason},
        )
        task_id = task.id
        print(f"[Task] Created task: {task_id}")

    # Execute with or without retry
    if args.retry:
        return execute_with_retry(
            decision.provider,
            message,
            use_daemon,
            tracker,
            task_id,
            max_retries=args.max_retries,
            verbose=args.verbose,
        )
    else:
        return execute_ask(
            decision.provider, message, use_daemon, tracker, task_id,
            cache_response=args.cache
        )


def cmd_multi_provider(args: argparse.Namespace, message: str, router: UnifiedRouter) -> int:
    """Execute query on multiple providers."""
    # Remove @all from message for actual query
    clean_message = message.replace("@all", "").replace("@ALL", "").strip()

    # Determine providers
    if args.providers:
        providers = [p.strip() for p in args.providers.split(",")]
    else:
        # Get from magic keyword config or use defaults
        magic_info = router.get_magic_keyword_info("@all")
        if magic_info and magic_info.get("providers"):
            providers = magic_info["providers"]
        else:
            providers = ["claude", "gemini", "codex"]

    # Determine strategy
    strategy_map = {
        "first": AggregationStrategy.FIRST_SUCCESS,
        "all": AggregationStrategy.ALL,
        "merge": AggregationStrategy.MERGE,
        "compare": AggregationStrategy.COMPARE,
    }
    strategy = strategy_map.get(args.strategy, AggregationStrategy.ALL)

    if args.verbose:
        print(f"[Multi] Querying providers: {', '.join(providers)}")
        print(f"[Multi] Strategy: {strategy.value}")

    # Execute
    executor = MultiProviderExecutor(
        providers=providers,
        strategy=strategy,
        timeout_s=args.timeout,
    )

    def on_result(result):
        if args.verbose:
            status = "OK" if result.success else "FAIL"
            print(f"[Multi] {result.provider}: {status} ({result.latency_ms:.0f}ms)")

    result = executor.execute_parallel(clean_message, on_result)

    # Record performance metrics
    perf_tracker = get_perf_tracker()
    for provider, pr in result.results.items():
        perf_tracker.record(
            provider=provider,
            latency_ms=pr.latency_ms,
            success=pr.success,
            error=pr.error,
        )

    # Output result
    output = format_multi_result(result, verbose=args.verbose)
    print(output)

    return 0 if result.successful_count > 0 else 1


def execute_with_retry(
    provider: str,
    message: str,
    use_daemon: bool,
    tracker: Optional[TaskTracker],
    task_id: Optional[str],
    max_retries: int = 3,
    verbose: bool = False,
) -> int:
    """Execute ask with automatic retry."""
    config = RetryConfig(max_attempts=max_retries)
    executor = RetryExecutor(config)

    def on_retry(attempt: RetryAttempt):
        if verbose:
            print(f"[Retry] Attempt {attempt.attempt_number} failed: {attempt.error}")
            print(f"[Retry] Trying provider: {attempt.provider}")

    def execute_fn(prov: str):
        """Execute function for retry."""
        ask_cmd = get_ask_command(prov)
        start_time = time.time()

        if use_daemon:
            cmd = f"{ask_cmd} <<'EOF'\n{message}\nEOF"
            result = subprocess.run(
                ["bash", "-c", cmd],
                capture_output=False,
            )
            success = result.returncode == 0
            error = None if success else f"Exit code: {result.returncode}"
            return success, None, error
        else:
            return False, None, "Direct CLI not implemented"

    result = executor.execute_with_retry(execute_fn, provider, on_retry)

    # Record performance for final attempt
    perf_tracker = get_perf_tracker()
    for attempt in result.attempts:
        perf_tracker.record(
            provider=attempt.provider,
            latency_ms=attempt.latency_ms,
            success=attempt.success,
            task_id=task_id,
            error=attempt.error,
        )

    # Update task status
    if tracker and task_id:
        if result.success:
            tracker.update_status(task_id, TaskStatus.COMPLETED)
        else:
            tracker.update_status(
                task_id,
                TaskStatus.FAILED,
                error=f"Failed after {result.total_attempts} attempts: {result.error}",
            )

    if verbose:
        print(f"[Retry] Completed: {result.total_attempts} attempts, final provider: {result.final_provider}")

    return 0 if result.success else 1


def main() -> int:
    parser = argparse.ArgumentParser(
        prog="ccb-ask",
        description="Intelligent routing CLI for CCB",
    )

    parser.add_argument(
        "message",
        nargs="*",
        help="Message to send to AI provider",
    )
    parser.add_argument(
        "-p", "--provider",
        choices=["claude", "gemini", "codex", "opencode", "deepseek", "droid", "iflow", "kimi", "qwen"],
        help="Force specific provider",
    )
    parser.add_argument(
        "-f", "--files",
        action="append",
        default=[],
        help="Files involved in the task (for routing). Can be specified multiple times.",
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Show routing decision",
    )
    parser.add_argument(
        "-t", "--track",
        action="store_true",
        help="Enable task tracking (creates task ID)",
    )
    parser.add_argument(
        "--route",
        action="store_true",
        help="Show routing decision only (don't execute)",
    )
    parser.add_argument(
        "--health",
        action="store_true",
        help="Check provider health status",
    )
    parser.add_argument(
        "--magic",
        action="store_true",
        help="List available magic keywords",
    )
    parser.add_argument(
        "--cache",
        action="store_true",
        default=False,
        help="Enable response caching (check cache before request)",
    )
    parser.add_argument(
        "--no-cache",
        action="store_true",
        help="Disable response caching",
    )
    parser.add_argument(
        "--retry",
        action="store_true",
        default=False,
        help="Enable automatic retry on failure",
    )
    parser.add_argument(
        "--no-retry",
        action="store_true",
        help="Disable automatic retry",
    )
    parser.add_argument(
        "--max-retries",
        type=int,
        default=3,
        help="Maximum retry attempts (default: 3)",
    )
    parser.add_argument(
        "--multi",
        action="store_true",
        help="Enable multi-provider execution (same as @all)",
    )
    parser.add_argument(
        "--providers",
        help="Comma-separated list of providers for multi-provider mode",
    )
    parser.add_argument(
        "--strategy",
        choices=["first", "all", "merge", "compare"],
        default="all",
        help="Aggregation strategy for multi-provider (default: all)",
    )
    parser.add_argument(
        "--timeout",
        type=float,
        default=60.0,
        help="Timeout per provider in seconds (default: 60)",
    )

    args = parser.parse_args()

    # Handle cache flag logic
    if args.no_cache:
        args.cache = False

    # Handle retry flag logic
    if args.no_retry:
        args.retry = False

    # Normalize files to list (action="append" creates list)
    if not args.files:
        args.files = None

    if args.health:
        return cmd_health(args)

    if args.magic:
        return cmd_magic(args)

    if args.route:
        if not args.message:
            print("Error: No message provided for routing", file=sys.stderr)
            return 1
        return cmd_route(args)

    if not args.message:
        parser.print_help()
        return 0

    return cmd_ask(args)


if __name__ == "__main__":
    sys.exit(main())
