#!/bin/bash
# CCB CLI ç»Ÿä¸€æ‰§è¡Œè„šæœ¬ (Gateway æ¨¡å¼)
# æ‰€æœ‰è°ƒç”¨èµ° Gateway APIï¼Œå®ç°ç»Ÿä¸€ç›‘æ§ã€ç¼“å­˜ã€é‡è¯•
# ç”¨æ³•: ccb-cli <provider> [model/mode] <prompt>

set -e

SCRIPTS_DIR="$HOME/.ccb_config/scripts"
GATEWAY_URL="${CCB_GATEWAY_URL:-http://localhost:8765}"
GATEWAY_TIMEOUT="${CCB_GATEWAY_TIMEOUT:-300}"
AGENT=""
ASYNC_MODE=false
STREAM_MODE=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# Parse global options first
POSITIONAL_ARGS=()
while [[ $# -gt 0 ]]; do
    case $1 in
        -a|--agent)
            AGENT="$2"
            shift 2
            ;;
        -t|--timeout)
            GATEWAY_TIMEOUT="$2"
            shift 2
            ;;
        --async)
            ASYNC_MODE=true
            shift
            ;;
        --stream|-s)
            STREAM_MODE=true
            shift
            ;;
        -h|--help|help)
            POSITIONAL_ARGS+=("help")
            shift
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
            shift
            ;;
    esac
done

# Restore positional parameters
set -- "${POSITIONAL_ARGS[@]}"

PROVIDER="$1"
shift 2>/dev/null || true

show_help() {
    cat << 'EOF'
CCB CLI ç»Ÿä¸€æ‰§è¡Œè„šæœ¬ (Gateway æ¨¡å¼)

ç”¨æ³•: ccb-cli <provider> [options] [model/mode] <prompt>

æ‰€æœ‰è°ƒç”¨å¼ºåˆ¶èµ° Gateway APIï¼Œå®ç°ï¼š
  - ç»Ÿä¸€ç›‘æ§ (Web UI: http://localhost:8765)
  - å“åº”ç¼“å­˜
  - è‡ªåŠ¨é‡è¯•
  - æ•°æ®æŒä¹…åŒ–
  - ğŸ†• åŒæ­¥è¶…æ—¶è‡ªåŠ¨åˆ‡æ¢å¼‚æ­¥ï¼ˆé¿å…é˜»å¡ï¼‰

å…¨å±€é€‰é¡¹:
  -a, --agent <role>    æŒ‡å®š Agent è§’è‰² (å¦‚ sisyphus, oracle, librarian)
  -t, --timeout <sec>   è¶…æ—¶ç§’æ•° (é»˜è®¤: 300)
  --async               å¼‚æ­¥æ¨¡å¼: ç«‹å³è¿”å› request_idï¼Œä¸ç­‰å¾…å®Œæˆ
  -s, --stream          æµå¼æ¨¡å¼: å¼‚æ­¥æäº¤åè‡ªåŠ¨è·Ÿè¸ªè¾“å‡º (ä½¿ç”¨ ccb-tail)

ğŸ†• è‡ªåŠ¨åˆ‡æ¢æœºåˆ¶:
  å½“åŒæ­¥è¯·æ±‚è¶…æ—¶æ—¶ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°å¼‚æ­¥æ¨¡å¼ï¼š
  1. ä¿ç•™ request_id ç»§ç»­åå°å¤„ç†
  2. æç¤ºç”¨æˆ·å¯å®æ—¶è·Ÿè¸ª (ccb-tail -f <id>)
  3. äº¤äº’æ¨¡å¼ä¸‹è¯¢é—®æ˜¯å¦ç«‹å³è·Ÿè¸ª
  4. é¿å… CLI é•¿æ—¶é—´é˜»å¡

Agent è§’è‰²:
  sisyphus   ğŸª¨ æŒç»­æ”¹è¿›ã€é”™è¯¯ä¿®å¤
  oracle     ğŸ”® é¢„æµ‹ã€è¶‹åŠ¿åˆ†æ
  librarian  ğŸ“š æ–‡æ¡£ã€çŸ¥è¯†æ•´ç†
  explorer   ğŸ§­ æ¢ç´¢ã€è°ƒç ”
  frontend   ğŸ¨ å‰ç«¯å¼€å‘
  reviewer   ğŸ” ä»£ç å®¡æŸ¥
  workflow   âš™ï¸ å·¥ä½œæµè‡ªåŠ¨åŒ–
  polyglot   ğŸŒ å¤šè¯­è¨€ç¿»è¯‘
  autonomous ğŸ¤– è‡ªä¸»å†³ç­–

Providers å’Œæ¨¡å‹é€‰é¡¹:
  kimi [thinking|normal] <prompt>     - Kimi (é»˜è®¤ normal)
  qwen <prompt>                       - Qwen (ä»… coder-model)
  iflow [thinking|normal] <prompt>    - iFlow GLM-4.7 (é»˜è®¤ normal)
  opencode [model] <prompt>           - OpenCode å¤šæ¨¡å‹
  codex [model] <prompt>              - Codex OpenAI
  gemini [model] <prompt>             - Gemini
  qoder <prompt>                      - Qoder ä»£ç åŠ©æ‰‹
  claude <prompt>                     - Claude (å¦ä¸€ä¸ª Claude å®ä¾‹)
  obsidian <command|prompt>           - Obsidian CLI (çŸ¥è¯†åº“æ“ä½œ)

æ¨¡å‹å¿«æ·æ–¹å¼:
  codex o3/o4-mini/gpt-4o/...
  gemini 3f/3p/2.5f/2.5p = gemini-3-flash-preview/...
  opencode mm/kimi/glm = minimax/kimi-k2.5/glm

ç¯å¢ƒå˜é‡:
  CCB_GATEWAY_URL     - Gateway åœ°å€ (é»˜è®¤: http://localhost:8765)
  CCB_GATEWAY_TIMEOUT - è¶…æ—¶ç§’æ•° (é»˜è®¤: 300)

ç¤ºä¾‹:
  ccb-cli kimi "ä½ å¥½"
  ccb-cli kimi thinking "åˆ†æè¿™ä¸ªé—®é¢˜"
  ccb-cli kimi -a sisyphus "ä¿®å¤è¿™ä¸ª bug"
  ccb-cli codex o4-mini -a reviewer "å®¡æŸ¥è¿™æ®µä»£ç "
  ccb-cli gemini 3f --agent frontend "React ç»„ä»¶"
  ccb-cli claude "é—®å¦ä¸€ä¸ª Claude"
EOF
}

# Check if Gateway is running, auto-start if not
check_gateway() {
    if curl -s --connect-timeout 2 "${GATEWAY_URL}/api/health" >/dev/null 2>&1; then
        return 0
    fi

    echo -e "${YELLOW}âš¡ Gateway æœªè¿è¡Œï¼Œæ­£åœ¨å¯åŠ¨...${NC}" >&2

    # Start Gateway in background using wrapper script (ensures env vars are loaded)
    cd ~/.local/share/codex-dual
    nohup bash bin/ccb-gateway-start.sh > /tmp/ccb-gateway.log 2>&1 &
    local gateway_pid=$!

    # Wait for Gateway to start (max 5 seconds)
    for i in {1..10}; do
        sleep 0.5
        if curl -s --connect-timeout 1 "${GATEWAY_URL}/api/health" >/dev/null 2>&1; then
            echo -e "${GREEN}âœ“ Gateway å·²å¯åŠ¨ (PID: $gateway_pid)${NC}" >&2
            return 0
        fi
    done

    echo -e "${RED}âœ– Gateway å¯åŠ¨å¤±è´¥${NC}" >&2
    echo -e "è¯·æ£€æŸ¥æ—¥å¿—: ${BLUE}/tmp/ccb-gateway.log${NC}" >&2
    echo -e "æ‰‹åŠ¨å¯åŠ¨: ${BLUE}cd ~/.local/share/codex-dual && python3 -m lib.gateway.gateway_server --port 8765${NC}" >&2
    exit 1
}

# Call Gateway API with wait=true
call_gateway() {
    local provider="$1"
    local message="$2"
    local timeout="${3:-$GATEWAY_TIMEOUT}"
    local agent="${4:-}"

    # Build JSON payload
    local payload
    if [[ -n "$agent" ]]; then
        payload=$(jq -n \
            --arg provider "$provider" \
            --arg message "$message" \
            --arg agent "$agent" \
            --argjson timeout_s "$timeout" \
            '{provider: $provider, message: $message, agent: $agent, timeout_s: $timeout_s}')
        echo -e "${PURPLE}ğŸ­ Agent: $agent${NC}" >&2
    else
        payload=$(jq -n \
            --arg provider "$provider" \
            --arg message "$message" \
            --argjson timeout_s "$timeout" \
            '{provider: $provider, message: $message, timeout_s: $timeout_s}')
    fi

    # Async mode: submit and return immediately
    if $ASYNC_MODE || $STREAM_MODE; then
        local response
        response=$(curl -s -X POST "${GATEWAY_URL}/api/ask?wait=false" \
            -H "Content-Type: application/json" \
            -d "$payload")

        local curl_exit=$?
        if [[ $curl_exit -ne 0 ]]; then
            echo -e "${RED}é”™è¯¯: Gateway è¯·æ±‚å¤±è´¥ (curl exit: $curl_exit)${NC}" >&2
            exit 1
        fi

        local request_id
        request_id=$(echo "$response" | jq -r '.request_id // empty')

        if [[ -z "$request_id" ]]; then
            echo -e "${RED}é”™è¯¯: æœªè·å–åˆ° request_id${NC}" >&2
            echo "$response" | jq . >&2
            exit 1
        fi

        if $STREAM_MODE; then
            # Stream mode: auto-tail the output
            echo -e "${GREEN}âœ“ å·²æäº¤: ${request_id}${NC}" >&2
            echo "" >&2
            # Wait a moment for stream file to be created
            sleep 0.5
            exec ccb-tail -f "$request_id"
        else
            # Async mode: just print request_id
            echo -e "${GREEN}âœ“ å·²æäº¤${NC}" >&2
            echo -e "Request ID: ${BLUE}$request_id${NC}"
            echo -e "æŸ¥çœ‹è¾“å‡º: ${BLUE}ccb-tail -f $request_id${NC}"
            echo -e "æŸ¥è¯¢çŠ¶æ€: ${BLUE}ccb-query get $request_id${NC}"
        fi
        return 0
    fi

    # Sync mode: Call Gateway API with wait=true
    local response
    response=$(curl -s -X POST "${GATEWAY_URL}/api/ask?wait=true&timeout=${timeout}" \
        -H "Content-Type: application/json" \
        -d "$payload" \
        --max-time $((timeout + 10)))

    local curl_exit=$?
    if [[ $curl_exit -ne 0 ]]; then
        echo -e "${RED}é”™è¯¯: Gateway è¯·æ±‚å¤±è´¥ (curl exit: $curl_exit)${NC}" >&2
        exit 1
    fi

    # Parse response
    local status
    status=$(echo "$response" | jq -r '.status // "unknown"')

    case "$status" in
        completed)
            # Extract and display response
            local result
            result=$(echo "$response" | jq -r '.response // empty')
            if [[ -n "$result" ]]; then
                echo "$result"
            else
                echo -e "${YELLOW}(ç©ºå“åº”)${NC}" >&2
            fi

            # Show cache info if cached
            local cached
            cached=$(echo "$response" | jq -r '.cached // false')
            if [[ "$cached" == "true" ]]; then
                echo -e "${GREEN}(æ¥è‡ªç¼“å­˜)${NC}" >&2
            fi
            ;;
        failed)
            # Check if there's a response despite failed status
            local result
            result=$(echo "$response" | jq -r '.response // empty')
            if [[ -n "$result" ]]; then
                echo "$result"
                exit 0
            fi
            # çœŸæ­£çš„å¤±è´¥ï¼šæ²¡æœ‰å“åº”
            local error
            error=$(echo "$response" | jq -r '.error // "No response available"')
            echo -e "${RED}é”™è¯¯: $error${NC}" >&2
            exit 1
            ;;
        timeout)
            local request_id
            request_id=$(echo "$response" | jq -r '.request_id // "unknown"')
            echo -e "${YELLOW}â±ï¸  åŒæ­¥è¯·æ±‚è¶…æ—¶ (${timeout}s)ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°å¼‚æ­¥æ¨¡å¼${NC}" >&2
            echo -e "${GREEN}âœ“ Request ID: ${BLUE}$request_id${NC}" >&2
            echo "" >&2
            echo -e "${BLUE}ğŸ“Š åå°ç»§ç»­å¤„ç†ä¸­...${NC}" >&2
            echo -e "${BLUE}å®æ—¶è·Ÿè¸ªè¾“å‡º: ccb-tail -f $request_id${NC}" >&2
            echo -e "${BLUE}æŸ¥è¯¢æœ€ç»ˆç»“æœ: ccb-query get $request_id${NC}" >&2
            echo "" >&2

            # Auto-switch: Ask user if they want to tail the output
            if [[ -t 0 ]]; then  # Check if stdin is a terminal (interactive)
                read -t 5 -p "æ˜¯å¦å®æ—¶è·Ÿè¸ªè¾“å‡ºï¼Ÿ[Y/n] " -n 1 -r
                echo "" >&2
                if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
                    echo -e "${GREEN}å¼€å§‹å®æ—¶è·Ÿè¸ª...${NC}" >&2
                    sleep 0.5
                    exec ccb-tail -f "$request_id"
                else
                    echo -e "${BLUE}ä»»åŠ¡åœ¨åå°ç»§ç»­æ‰§è¡Œ${NC}" >&2
                fi
            else
                # Non-interactive: just print info
                echo -e "${BLUE}ä»»åŠ¡åœ¨åå°ç»§ç»­æ‰§è¡Œï¼ˆéäº¤äº’æ¨¡å¼ï¼‰${NC}" >&2
            fi
            exit 0  # Changed from exit 1 to exit 0 (not an error, just async now)
            ;;
        *)
            echo -e "${RED}æœªçŸ¥çŠ¶æ€: $status${NC}" >&2
            echo "$response" | jq . >&2
            exit 1
            ;;
    esac
}

# Parse provider and model/mode, build message for Gateway
parse_and_call() {
    local provider="$1"
    shift
    local args=("$@")
    local message=""
    local model_info=""

    case "$provider" in
        kimi)
            local mode="${args[0]:-normal}"
            if [[ "$mode" == "thinking" || "$mode" == "normal" ]]; then
                message="${args[*]:1}"
                model_info="[mode=$mode]"
            else
                mode="normal"
                message="${args[*]}"
            fi
            # Prepend mode info for Gateway backend to use
            if [[ "$mode" == "thinking" ]]; then
                message="[THINKING_MODE] $message"
            fi
            ;;
        qwen)
            message="${args[*]}"
            ;;
        iflow)
            local mode="${args[0]:-normal}"
            if [[ "$mode" == "thinking" || "$mode" == "normal" ]]; then
                message="${args[*]:1}"
            else
                mode="normal"
                message="${args[*]}"
            fi
            if [[ "$mode" == "thinking" ]]; then
                message="[THINKING_MODE] $message"
            fi
            ;;
        opencode)
            local model="${args[0]:-minimax-cn-coding-plan/MiniMax-M2.5}"
            case "$model" in
                mm|minimax) model="minimax-cn-coding-plan/MiniMax-M2.5"; message="${args[*]:1}" ;;
                free) model="opencode/minimax-m2.5-free"; message="${args[*]:1}" ;;
                kimi|k) model="opencode/kimi-k2.5-free"; message="${args[*]:1}" ;;
                glm) model="opencode/glm-4.7-free"; message="${args[*]:1}" ;;
                *)
                    if [[ "$model" != opencode/* && "$model" != minimax* ]]; then
                        model="minimax-cn-coding-plan/MiniMax-M2.5"
                        message="${args[*]}"
                    else
                        message="${args[*]:1}"
                    fi
                    ;;
            esac
            message="[MODEL:$model] $message"
            ;;
        codex)
            local model="${args[0]:-o3}"
            case "$model" in
                o3|o4-mini|o3-mini|o1|o1-pro|gpt-5.2-codex|gpt-4.5|gpt-4.1|gpt-4o)
                    message="${args[*]:1}" ;;
                *)
                    model="o3"
                    message="${args[*]}" ;;
            esac
            message="[MODEL:$model] $message"
            ;;
        gemini)
            local model="${args[0]:-gemini-3-flash-preview}"
            case "$model" in
                3f|3-flash) model="gemini-3-flash-preview"; message="${args[*]:1}" ;;
                3p|3-pro) model="gemini-3-pro-preview"; message="${args[*]:1}" ;;
                2.5f|2.5-flash) model="gemini-2.5-flash"; message="${args[*]:1}" ;;
                2.5p|2.5-pro) model="gemini-2.5-pro"; message="${args[*]:1}" ;;
                2f|2-flash) model="gemini-2.0-flash"; message="${args[*]:1}" ;;
                gemini-*) message="${args[*]:1}" ;;
                *)
                    model="gemini-3-flash-preview"
                    message="${args[*]}" ;;
            esac
            message="[MODEL:$model] $message"
            ;;
        qoder)
            # Qoder: simple pass-through, no special model modes
            message="${args[*]}"
            ;;
        claude)
            # Claude: call another Claude instance via Gateway
            message="${args[*]}"
            ;;
        obsidian)
            # Obsidian CLI: supports two modes
            # 1) Direct command mode: ccb-cli obsidian "files total"
            # 2) Natural language mode: ccb-cli obsidian "åˆ—å‡ºæ‰€æœ‰æ–‡ä»¶"
            message="${args[*]}"

            # Detect direct Obsidian CLI command keywords
            if [[ "$message" =~ ^(create|files|search|append|daily|daily:|folders|file|delete|aliases|backlinks|history|bookmarks|bookmark|commands|help|base:|bases) ]]; then
                message="[OBSIDIAN_CMD] $message"
            else
                message="[OBSIDIAN_NL] $message"
            fi
            ;;
        antigravity)
            # Antigravity Tools: local proxy
            message="${args[*]}"
            ;;
        *)
            echo -e "${RED}æœªçŸ¥ provider: $provider${NC}" >&2
            show_help
            exit 1
            ;;
    esac

    if [[ -z "$message" ]]; then
        echo -e "${RED}é”™è¯¯: éœ€è¦æä¾› prompt${NC}" >&2
        exit 1
    fi

    echo -e "${YELLOW}[DEBUG] provider=$provider, message=$message${NC}" >&2
    call_gateway "$provider" "$message" "$GATEWAY_TIMEOUT" "$AGENT"
}

# Main entry point
case "$PROVIDER" in
    help|-h|--help|"")
        show_help
        exit 0
        ;;
    *)
        # Check if jq is available
        if ! command -v jq &>/dev/null; then
            echo -e "${RED}é”™è¯¯: éœ€è¦ jq å‘½ä»¤${NC}" >&2
            echo "å®‰è£…: brew install jq" >&2
            exit 1
        fi

        # Gateway is required
        check_gateway
        parse_and_call "$PROVIDER" "$@"
        ;;
esac
