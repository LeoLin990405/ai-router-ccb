#!/usr/bin/env python3.13
"""
dskask - Send message to DeepSeek via CCB daemon (preferred) or direct API.

Direct API mode supports both deepseek-chat (V3) and deepseek-reasoner (R1).
"""

from __future__ import annotations

import os
import sys
import json
import urllib.request
import urllib.error
import time
from pathlib import Path

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))

try:
    from compat import read_stdin_text, setup_windows_encoding
    setup_windows_encoding()
except ImportError:
    def read_stdin_text():
        return sys.stdin.read()

from cli_output import EXIT_ERROR, EXIT_NO_REPLY, EXIT_OK, atomic_write_text
from env_utils import env_bool
from askd_client import (
    state_file_from_env,
    find_project_session_file,
    has_active_session,
    resolve_work_dir_with_registry,
    try_daemon_request,
    maybe_start_daemon,
    wait_for_daemon_ready,
    maybe_start_sidecar,
    signal_sidecar_done,
)
from providers import DSKASK_CLIENT_SPEC
from gateway_client import is_gateway_enabled, gateway_ask_deepseek


ASYNC_GUARDRAIL = """[CCB_ASYNC_SUBMITTED provider=deepseek]
IMPORTANT: Task submitted to DeepSeek. You MUST:
1. Tell user "DeepSeek processing..."
2. END YOUR TURN IMMEDIATELY
3. Do NOT wait, poll, check status, or use any more tools
"""

API_URL = "https://api.deepseek.com/chat/completions"
DEFAULT_MODEL = "deepseek-chat"  # or "deepseek-reasoner" for R1


def _usage() -> None:
    print("Usage: dskask [--sync] [--session-file FILE] [--timeout SECONDS] [--output FILE] [--direct] [--model MODEL] [--show-thinking] <message>", file=sys.stderr)


def _resolve_model(model_arg: str) -> str:
    model_lower = model_arg.lower()
    if model_lower in ("r1", "reasoner", "deepseek-reasoner"):
        return "deepseek-reasoner"
    if model_lower in ("chat", "v3", "deepseek-chat"):
        return "deepseek-chat"
    return model_arg


def _call_api(message: str, model: str, api_key: str, timeout: float) -> dict:
    payload = {
        "model": model,
        "messages": [{"role": "user", "content": message}],
        "max_tokens": 4096,
    }

    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}",
    }

    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(API_URL, data=data, headers=headers, method="POST")

    with urllib.request.urlopen(req, timeout=timeout) as resp:
        return json.loads(resp.read().decode("utf-8"))


def _daemon_startup_wait_s(timeout: float) -> float:
    raw = (os.environ.get("CCB_DSKASKD_STARTUP_WAIT_S") or "").strip()
    if raw:
        try:
            v = float(raw)
        except Exception:
            v = 0.0
        if v > 0:
            return min(max(0.2, v), max(0.2, float(timeout)))
    return min(8.0, max(1.0, float(timeout)))


def _daemon_retry_wait_s(timeout: float) -> float:
    raw = (os.environ.get("CCB_DSKASKD_RETRY_WAIT_S") or "").strip()
    if raw:
        try:
            v = float(raw)
        except Exception:
            v = 0.0
        if v > 0:
            return min(1.0, max(0.05, v))
    return min(0.3, max(0.05, float(timeout) / 50.0))


def _daemon_request_with_retries(work_dir: Path, message: str, timeout: float, quiet: bool) -> tuple[str, int] | None:
    """
    Best-effort daemon request with retries to avoid autostart races.

    Without this, concurrent first invocations can all try to start the daemon and some calls may fail.
    """
    state_file = state_file_from_env(DSKASK_CLIENT_SPEC.state_file_env)
    if env_bool("CCB_DSKASKD_FORCE_SIDECAR", False):
        os.environ.setdefault("CCB_SIDECAR_AUTOSTART", "1")
    sidecar_started_at = time.time()
    sidecar_wait_file = maybe_start_sidecar(DSKASK_CLIENT_SPEC, work_dir, provider="deepseek", request_timeout_s=timeout)

    try:
        result = try_daemon_request(DSKASK_CLIENT_SPEC, work_dir, message, timeout, quiet, state_file)
        if result is not None:
            return result

        if not env_bool(DSKASK_CLIENT_SPEC.enabled_env, True):
            return None
        if not has_active_session(DSKASK_CLIENT_SPEC, work_dir):
            return None

        if state_file and state_file.exists():
            try:
                from dskaskd_daemon import ping_daemon

                if not ping_daemon(timeout_s=0.2, state_file=state_file):
                    try:
                        state_file.unlink()
                    except Exception:
                        pass
            except Exception:
                pass

        started = maybe_start_daemon(DSKASK_CLIENT_SPEC, work_dir)
        if started:
            wait_for_daemon_ready(DSKASK_CLIENT_SPEC, _daemon_startup_wait_s(timeout), state_file)

        wait_s = _daemon_retry_wait_s(timeout)
        deadline = time.time() + min(3.0, max(0.2, float(timeout)))
        while time.time() < deadline:
            result = try_daemon_request(DSKASK_CLIENT_SPEC, work_dir, message, timeout, quiet, state_file)
            if result is not None:
                return result
            time.sleep(wait_s)

        return None
    finally:
        min_open_s = 0.0
        raw_min_open = (os.environ.get("CCB_DSKASKD_SIDECAR_MIN_OPEN_S") or "").strip()
        if raw_min_open:
            try:
                min_open_s = float(raw_min_open)
            except Exception:
                min_open_s = 0.0
        if sidecar_wait_file and min_open_s > 0:
            elapsed = time.time() - sidecar_started_at
            if elapsed < min_open_s:
                time.sleep(min_open_s - elapsed)
        signal_sidecar_done(sidecar_wait_file)

def _direct_api_call(message: str, model: str, timeout: float, show_thinking: bool) -> tuple[str, dict]:
    api_key = os.environ.get("DEEPSEEK_API_KEY")
    if not api_key:
        raise RuntimeError("[ERROR] DEEPSEEK_API_KEY not set. Get one at https://platform.deepseek.com/")

    response = _call_api(message, model, api_key, timeout)
    choice = response.get("choices", [{}])[0]
    msg = choice.get("message", {})
    content = msg.get("content", "")
    reasoning = msg.get("reasoning_content", "")

    if reasoning and show_thinking:
        parts = []
        parts.append("=" * 60)
        parts.append("Reasoning:")
        parts.append("=" * 60)
        parts.append(reasoning)
        parts.append("")
        parts.append("=" * 60)
        parts.append("Response:")
        parts.append("=" * 60)
        parts.append(content)
        content = "\n".join(parts).strip()

    usage = response.get("usage", {}) if isinstance(response, dict) else {}
    return content, usage if isinstance(usage, dict) else {}


def main(argv: list[str]) -> int:
    if len(argv) <= 1 and sys.stdin.isatty():
        _usage()
        return EXIT_ERROR

    output_path: Path | None = None
    timeout: float | None = None
    quiet = False
    sync_mode = False
    session_file: str | None = None
    direct_mode = False
    show_thinking = False
    model = DEFAULT_MODEL

    parts: list[str] = []
    it = iter(argv[1:])
    for token in it:
        if token in ("-h", "--help"):
            _usage()
            return EXIT_OK
        if token in ("-q", "--quiet"):
            quiet = True
            continue
        if token == "--sync":
            sync_mode = True
            continue
        if token == "--session-file":
            try:
                session_file = next(it)
            except StopIteration:
                print("[ERROR] --session-file requires a file path", file=sys.stderr)
                return EXIT_ERROR
            continue
        if token in ("-o", "--output"):
            try:
                output_path = Path(next(it)).expanduser()
            except StopIteration:
                print("[ERROR] --output requires a file path", file=sys.stderr)
                return EXIT_ERROR
            continue
        if token in ("-t", "--timeout"):
            try:
                timeout = float(next(it))
            except StopIteration:
                print("[ERROR] --timeout requires a number", file=sys.stderr)
                return EXIT_ERROR
            except ValueError:
                print("[ERROR] --timeout must be a number", file=sys.stderr)
                return EXIT_ERROR
            continue
        if token in ("-m", "--model"):
            try:
                model = _resolve_model(next(it))
            except StopIteration:
                print("[ERROR] --model requires a value", file=sys.stderr)
                return EXIT_ERROR
            direct_mode = True
            continue
        if token == "--show-thinking":
            show_thinking = True
            direct_mode = True
            continue
        if token == "--direct":
            direct_mode = True
            continue
        parts.append(token)

    message = " ".join(parts).strip()
    if not message and not sys.stdin.isatty():
        message = read_stdin_text().strip()
    if not message:
        print("[ERROR] Message cannot be empty", file=sys.stderr)
        return EXIT_ERROR

    if timeout is None:
        try:
            timeout = float(os.environ.get("CCB_SYNC_TIMEOUT", "3600.0"))
        except Exception:
            timeout = 3600.0

    try:
        # Gateway mode: use Gateway API instead of daemon
        if is_gateway_enabled() and not direct_mode:
            reply, exit_code = gateway_ask_deepseek(message, timeout_s=timeout if timeout > 0 else 600.0, wait=True)
            if reply:
                if output_path:
                    atomic_write_text(output_path, reply + "\n")
                    return exit_code
                sys.stdout.write(reply)
                if not reply.endswith("\n"):
                    sys.stdout.write("\n")
            return exit_code

        if not direct_mode:
            work_dir, _ = resolve_work_dir_with_registry(
                DSKASK_CLIENT_SPEC,
                provider="deepseek",
                cli_session_file=session_file,
                env_session_file=os.environ.get("CCB_SESSION_FILE"),
            )

            daemon_result = _daemon_request_with_retries(work_dir, message, timeout, quiet)
            if daemon_result is not None:
                reply, exit_code = daemon_result
                if not sync_mode:
                    print(ASYNC_GUARDRAIL, file=sys.stderr, flush=True)
                if output_path:
                    atomic_write_text(output_path, reply + "\n")
                    return exit_code
                sys.stdout.write(reply)
                if not reply.endswith("\n"):
                    sys.stdout.write("\n")
                return exit_code

            session_exists = bool(has_active_session(DSKASK_CLIENT_SPEC, work_dir))
            if session_exists:
                if not env_bool(DSKASK_CLIENT_SPEC.enabled_env, True):
                    print(f"[ERROR] {DSKASK_CLIENT_SPEC.enabled_env}=0: dskask daemon mode disabled.", file=sys.stderr)
                    return EXIT_ERROR
                print("[ERROR] dskask daemon required but not available.", file=sys.stderr)
                print("Start it with `dskaskd` (or enable autostart via CCB_DSKASKD_AUTOSTART=1).", file=sys.stderr)
                print("Use --direct to bypass daemon mode.", file=sys.stderr)
                return EXIT_ERROR

        content, usage = _direct_api_call(message, model, timeout, show_thinking)
        if not sync_mode:
            print(ASYNC_GUARDRAIL, file=sys.stderr, flush=True)
        if output_path:
            atomic_write_text(output_path, content + "\n")
            return EXIT_OK
        sys.stdout.write(content)
        if not content.endswith("\n"):
            sys.stdout.write("\n")
        if usage and sync_mode:
            total = usage.get("total_tokens", 0)
            print(f"\n[Tokens: {total} | Model: {model}]", file=sys.stderr)
        return EXIT_OK
    except urllib.error.HTTPError as e:
        error_body = e.read().decode("utf-8") if e.fp else ""
        print(f"[ERROR] API error {e.code}: {error_body}", file=sys.stderr)
        return EXIT_ERROR
    except urllib.error.URLError as e:
        print(f"[ERROR] Network error: {e.reason}", file=sys.stderr)
        return EXIT_ERROR
    except TimeoutError:
        print(f"[ERROR] Request timed out after {timeout}s", file=sys.stderr)
        return EXIT_ERROR
    except Exception as e:
        print(f"[ERROR] {e}", file=sys.stderr)
        return EXIT_ERROR


if __name__ == "__main__":
    sys.exit(main(sys.argv))
