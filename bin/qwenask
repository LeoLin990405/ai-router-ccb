#!/usr/bin/env python3
"""
qwenask - Send message to Qwen API and get reply (headless mode).

Uses Alibaba Cloud DashScope API directly, no WezTerm pane required.
"""

from __future__ import annotations

import os
import sys
import json
import urllib.request
import urllib.error
from pathlib import Path
from typing import Optional

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))

try:
    from compat import read_stdin_text, setup_windows_encoding
    setup_windows_encoding()
except ImportError:
    def read_stdin_text():
        return sys.stdin.read()

ASYNC_GUARDRAIL = """[CCB_ASYNC_SUBMITTED provider=qwen]
IMPORTANT: Task submitted to Qwen. You MUST:
1. Tell user "Qwen processing..."
2. END YOUR TURN IMMEDIATELY
3. Do NOT wait, poll, check status, or use any more tools
"""

API_URL = "https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions"
DEFAULT_MODEL = "qwen-plus"


def _usage() -> None:
    print("Usage: qwenask [options] <message>", file=sys.stderr)
    print("  Or pipe: echo 'message' | qwenask", file=sys.stderr)
    print("", file=sys.stderr)
    print("Options:", file=sys.stderr)
    print("  --model MODEL    Model: plus (default), turbo, max, long", file=sys.stderr)
    print("  --timeout SECS   Timeout in seconds (default: 300)", file=sys.stderr)
    print("  --sync           Synchronous mode (no async guardrail)", file=sys.stderr)
    print("  -h, --help       Show this help", file=sys.stderr)


def _resolve_model(model_arg: str) -> str:
    model_lower = model_arg.lower()
    if model_lower in ("plus", "qwen-plus"):
        return "qwen-plus"
    elif model_lower in ("turbo", "qwen-turbo"):
        return "qwen-turbo"
    elif model_lower in ("max", "qwen-max"):
        return "qwen-max"
    elif model_lower in ("long", "qwen-long"):
        return "qwen-long"
    else:
        return model_arg


def _call_api(message: str, model: str, api_key: str, timeout: float) -> dict:
    payload = {
        "model": model,
        "messages": [{"role": "user", "content": message}],
        "max_tokens": 4096,
    }
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}",
    }
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(API_URL, data=data, headers=headers, method="POST")
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        return json.loads(resp.read().decode("utf-8"))


def main(argv: list[str]) -> int:
    if len(argv) <= 1 and sys.stdin.isatty():
        _usage()
        return 1

    timeout: float = 300.0
    sync_mode = False
    model = DEFAULT_MODEL
    parts: list[str] = []

    it = iter(argv[1:])
    for token in it:
        if token in ("-h", "--help"):
            _usage()
            return 0
        if token == "--sync":
            sync_mode = True
            continue
        if token in ("-m", "--model"):
            try:
                model = _resolve_model(next(it))
            except StopIteration:
                print("[ERROR] --model requires a value", file=sys.stderr)
                return 1
            continue
        if token in ("-t", "--timeout"):
            try:
                timeout = float(next(it))
            except (StopIteration, ValueError):
                print("[ERROR] --timeout requires a number", file=sys.stderr)
                return 1
            continue
        parts.append(token)

    message = " ".join(parts).strip()
    if not message and not sys.stdin.isatty():
        message = read_stdin_text().strip()
    if not message:
        print("[ERROR] Message cannot be empty", file=sys.stderr)
        return 1

    api_key = os.environ.get("DASHSCOPE_API_KEY") or os.environ.get("QWEN_API_KEY")
    if not api_key:
        print("[ERROR] DASHSCOPE_API_KEY not set. Get one at https://dashscope.console.aliyun.com/", file=sys.stderr)
        return 1

    try:
        response = _call_api(message, model, api_key, timeout)
        if not sync_mode:
            print(ASYNC_GUARDRAIL, file=sys.stderr, flush=True)

        choice = response.get("choices", [{}])[0]
        content = choice.get("message", {}).get("content", "")
        if content:
            print(content)

        usage = response.get("usage", {})
        if usage and sync_mode:
            print(f"\n[Tokens: {usage.get('total_tokens', 0)} | Model: {model}]", file=sys.stderr)
        return 0

    except urllib.error.HTTPError as e:
        error_body = e.read().decode("utf-8") if e.fp else ""
        print(f"[ERROR] API error {e.code}: {error_body}", file=sys.stderr)
        return 1
    except urllib.error.URLError as e:
        print(f"[ERROR] Network error: {e.reason}", file=sys.stderr)
        return 1
    except TimeoutError:
        print(f"[ERROR] Request timed out after {timeout}s", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"[ERROR] {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main(sys.argv))
