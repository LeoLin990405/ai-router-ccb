#!/usr/bin/env python3
"""
ccb-mem - CCB Memory System CLI

Commands:
  save [session_path]     Save a session to context archive
  consolidate [--hours N] Consolidate recent sessions to long-term memory
  search <keyword>        Search memory archives
  show <date>             Show memory for a specific date
  inject <date>           Output path for @ injection in new conversations
  list                    List recent archives and memories

Phase 7 New Commands:
  trace <request_id>      Trace injection details for a request
  injections [--limit N]  Show recent memory injections
  stats [--detailed]      Show memory system statistics
  export [--format json]  Export memory to file

Phase 8 New Commands:
  sync-streams [--force]  Sync stream files to database
  stream <request_id>     View stream entries from database
  thinking <request_id>   View thinking chain for a request
  timeline <request_id>   View execution timeline for a request

v2.0 Heuristic Commands:
  importance <id> <score> Set importance score (0.0-1.0)
  decay [--all]           Apply time-based decay
  forget <id>             Mark memory for forgetting
  search-scored <query>   Search with R/I/T scores
"""

import argparse
import json
import os
import re
import sys
from datetime import datetime, timedelta
from pathlib import Path
from typing import List, Optional

# Add lib directory to path - resolve symlinks first
SCRIPT_PATH = Path(__file__).resolve()
LIB_DIR = SCRIPT_PATH.parent.parent / "lib"
sys.path.insert(0, str(LIB_DIR))

from memory.context_saver import ContextSaver, find_current_session
from memory.consolidator import NightlyConsolidator

# Gateway API URL
GATEWAY_URL = "http://localhost:8765"


class CCBMemoryCLI:
    """CLI interface for CCB memory system."""

    def __init__(self):
        self.archive_dir = Path.home() / ".ccb" / "context_archive"
        self.memory_dir = Path.home() / ".ccb" / "memories"

        # Ensure directories exist
        self.archive_dir.mkdir(parents=True, exist_ok=True)
        self.memory_dir.mkdir(parents=True, exist_ok=True)

    def cmd_save(self, session_path: Optional[str] = None, force: bool = False) -> int:
        """Save a session to context archive."""
        if session_path:
            path = Path(session_path)
        else:
            # Try to get from environment (set by hook)
            env_path = os.environ.get('CLAUDE_SESSION_PATH')
            if env_path:
                path = Path(env_path)
            else:
                path = find_current_session()

        if not path:
            print("‚úñ No session file found", file=sys.stderr)
            print("  Usage: ccb-mem save <session.jsonl>", file=sys.stderr)
            return 1

        if not path.exists():
            print(f"‚úñ Session file not found: {path}", file=sys.stderr)
            return 1

        saver = ContextSaver(archive_dir=self.archive_dir)
        result = saver.save_session(path, force=force)

        if result:
            print(f"‚úì Saved context to: {result}")
            return 0
        else:
            print("Session too short or trivial, skipped")
            return 0

    def cmd_consolidate(self, hours: int = 24, use_llm: bool = False,
                        llm_provider: str = "kimi", dry_run: bool = False) -> int:
        """Consolidate recent sessions into long-term memory."""
        consolidator = NightlyConsolidator(
            archive_dir=self.archive_dir,
            memory_dir=self.memory_dir,
            llm_provider=llm_provider
        )

        print(f"Consolidating sessions from the last {hours} hours...")
        if use_llm:
            print(f"Using LLM provider: {llm_provider}")

        # Choose consolidation method
        if use_llm:
            import asyncio
            memory = asyncio.run(consolidator.consolidate_with_llm(hours=hours))
        else:
            memory = consolidator.consolidate(hours=hours)

        if memory.get("status") == "no_sessions":
            print("No sessions found in the specified time range")
            return 0

        if dry_run:
            print("\n[DRY RUN] Would save the following:")
            import json
            print(json.dumps(memory, indent=2, ensure_ascii=False)[:2000])
            return 0

        print(f"\nConsolidation complete!")
        print(f"  Sessions processed: {memory.get('sessions_processed', 0)}")
        print(f"  Models used: {', '.join(memory.get('models_used', []))}")

        if memory.get('project_progress'):
            print(f"  Projects: {', '.join(memory['project_progress'].keys())}")

        if memory.get('llm_enhanced'):
            print(f"\n  LLM Enhancement:")
            print(f"    Learnings: {len(memory.get('llm_learnings', []))}")
            print(f"    Preferences: {len(memory.get('llm_preferences', []))}")
            print(f"    Patterns: {len(memory.get('llm_patterns', []))}")
        elif memory.get('llm_error'):
            print(f"\n  LLM Error: {memory.get('llm_error')}")

        return 0

    def cmd_search(self, keyword: str) -> int:
        """Search memory archives for a keyword."""
        print(f"Searching for: {keyword}\n")

        results = []

        # Search in context archives
        for archive in self.archive_dir.glob("*.md"):
            content = archive.read_text(encoding='utf-8')
            if keyword.lower() in content.lower():
                # Find matching lines
                matches = []
                for i, line in enumerate(content.split('\n')):
                    if keyword.lower() in line.lower():
                        matches.append((i + 1, line.strip()[:80]))
                results.append({
                    'type': 'archive',
                    'path': archive,
                    'matches': matches[:3]  # Limit to 3 matches per file
                })

        # Search in memory files
        for memory in self.memory_dir.glob("*.md"):
            content = memory.read_text(encoding='utf-8')
            if keyword.lower() in content.lower():
                matches = []
                for i, line in enumerate(content.split('\n')):
                    if keyword.lower() in line.lower():
                        matches.append((i + 1, line.strip()[:80]))
                results.append({
                    'type': 'memory',
                    'path': memory,
                    'matches': matches[:3]
                })

        if not results:
            print("No matches found")
            return 0

        print(f"Found {len(results)} files:\n")

        for result in results[:20]:  # Limit to 20 results
            type_emoji = "üìù" if result['type'] == 'archive' else "üß†"
            print(f"{type_emoji} {result['path'].name}")
            for line_num, line in result['matches']:
                # Highlight keyword
                highlighted = re.sub(
                    f'({re.escape(keyword)})',
                    r'\033[1;33m\1\033[0m',
                    line,
                    flags=re.IGNORECASE
                )
                print(f"   L{line_num}: {highlighted}")
            print()

        return 0

    def cmd_show(self, date_str: str) -> int:
        """Show memory for a specific date."""
        # Validate date format
        try:
            if date_str == 'today':
                date = datetime.now()
            elif date_str == 'yesterday':
                date = datetime.now() - timedelta(days=1)
            else:
                date = datetime.strptime(date_str, "%Y-%m-%d")
        except ValueError:
            print(f"‚úñ Invalid date format: {date_str}", file=sys.stderr)
            print("  Use: YYYY-MM-DD, 'today', or 'yesterday'", file=sys.stderr)
            return 1

        date_formatted = date.strftime("%Y-%m-%d")

        # Look for memory file
        memory_file = self.memory_dir / f"{date_formatted}.md"
        if memory_file.exists():
            print(f"=== Memory for {date_formatted} ===\n")
            print(memory_file.read_text(encoding='utf-8'))
            return 0

        # Look for archives from that date
        archives = list(self.archive_dir.glob(f"{date_formatted}*.md"))
        if archives:
            print(f"=== Archives for {date_formatted} ({len(archives)} files) ===\n")
            for archive in archives:
                print(f"üìù {archive.name}")
                # Show first few lines
                lines = archive.read_text(encoding='utf-8').split('\n')[:10]
                for line in lines:
                    print(f"   {line}")
                print()
            return 0

        print(f"No memory or archives found for {date_formatted}")
        return 1

    def cmd_inject(self, date_str: str) -> int:
        """Output path for @ injection in new conversations."""
        # Validate date
        try:
            if date_str == 'today':
                date = datetime.now()
            elif date_str == 'yesterday':
                date = datetime.now() - timedelta(days=1)
            else:
                date = datetime.strptime(date_str, "%Y-%m-%d")
        except ValueError:
            print(f"‚úñ Invalid date: {date_str}", file=sys.stderr)
            return 1

        date_formatted = date.strftime("%Y-%m-%d")

        # Prefer memory file, then archives
        memory_file = self.memory_dir / f"{date_formatted}.md"
        if memory_file.exists():
            print(str(memory_file))
            return 0

        archives = sorted(self.archive_dir.glob(f"{date_formatted}*.md"))
        if archives:
            # Return the most recent archive for that date
            print(str(archives[-1]))
            return 0

        print(f"‚úñ No files found for {date_formatted}", file=sys.stderr)
        return 1

    def cmd_list(self, limit: int = 10) -> int:
        """List recent archives and memories."""
        print("=== Recent Context Archives ===\n")

        archives = sorted(
            self.archive_dir.glob("*.md"),
            key=lambda p: p.stat().st_mtime,
            reverse=True
        )[:limit]

        if archives:
            for archive in archives:
                mtime = datetime.fromtimestamp(archive.stat().st_mtime)
                size = archive.stat().st_size
                print(f"  üìù {archive.name:<40} {mtime.strftime('%m-%d %H:%M'):<12} {size:>6}B")
        else:
            print("  (no archives)")

        print("\n=== Long-term Memories ===\n")

        memories = sorted(
            self.memory_dir.glob("*.md"),
            key=lambda p: p.name,
            reverse=True
        )[:limit]

        if memories:
            for memory in memories:
                size = memory.stat().st_size
                print(f"  üß† {memory.name:<40} {size:>6}B")
        else:
            print("  (no memories)")

        return 0

    # ========================================================================
    # Phase 7: New CLI Commands
    # ========================================================================

    def cmd_trace(self, request_id: str) -> int:
        """Trace injection details for a specific request."""
        try:
            import httpx

            response = httpx.get(
                f"{GATEWAY_URL}/api/memory/request/{request_id}",
                timeout=10.0
            )

            if response.status_code == 404:
                print(f"‚úñ No injection record found for request: {request_id}", file=sys.stderr)
                return 1

            if response.status_code != 200:
                print(f"‚úñ API error: {response.status_code}", file=sys.stderr)
                return 1

            data = response.json()
            injection = data.get("injection", {})
            memories = data.get("injected_memories", [])

            print(f"=== Injection Trace: {request_id[:12]}... ===\n")

            # Basic info
            print(f"Provider:     {injection.get('provider', 'unknown')}")
            print(f"Timestamp:    {injection.get('injection_timestamp', 'unknown')}")
            print(f"Memory Count: {injection.get('memory_count', 0)}")
            print(f"Skills Count: {injection.get('skills_count', 0)}")
            print(f"System Ctx:   {'Yes' if injection.get('injected_system_context') else 'No'}")

            # Original message
            original = injection.get('original_message', '')
            if original:
                print(f"\nOriginal Message:")
                print(f"  {original[:200]}{'...' if len(original) > 200 else ''}")

            # Injected skills
            skills = injection.get('injected_skills', [])
            if skills:
                print(f"\nInjected Skills:")
                for skill in skills:
                    print(f"  ‚Ä¢ {skill}")

            # Injected memories
            if memories:
                print(f"\nInjected Memories:")
                for mem in memories:
                    score = mem.get('relevance_score', '-')
                    content = mem.get('content', '')[:100]
                    print(f"  [{mem.get('provider', '?')}] {content}...")
                    if score != '-':
                        print(f"       (relevance: {score})")

            return 0

        except ImportError:
            print("‚úñ httpx not installed. Run: pip install httpx", file=sys.stderr)
            return 1
        except Exception as e:
            print(f"‚úñ Error: {e}", file=sys.stderr)
            return 1

    def cmd_injections(self, limit: int = 10, session_id: str = None) -> int:
        """Show recent memory injections."""
        try:
            import httpx

            params = {"limit": limit}
            if session_id:
                params["session_id"] = session_id

            response = httpx.get(
                f"{GATEWAY_URL}/api/memory/injections",
                params=params,
                timeout=10.0
            )

            if response.status_code != 200:
                print(f"‚úñ API error: {response.status_code}", file=sys.stderr)
                return 1

            data = response.json()
            injections = data.get("injections", [])

            if not injections:
                print("No recent injections found")
                return 0

            print(f"=== Recent Memory Injections ({len(injections)}) ===\n")

            for inj in injections:
                req_id = inj.get("request_id", "?")[:12]
                provider = inj.get("provider", "?")
                mem_count = inj.get("memory_count", 0)
                skill_count = inj.get("skills_count", 0)
                timestamp = inj.get("injection_timestamp", "")[:16]

                print(f"  {timestamp}  {req_id}...  [{provider}]  "
                      f"üìö{mem_count} üõ†Ô∏è{skill_count}")

            print(f"\nUse 'ccb-mem trace <request_id>' for details")
            return 0

        except ImportError:
            print("‚úñ httpx not installed. Run: pip install httpx", file=sys.stderr)
            return 1
        except Exception as e:
            print(f"‚úñ Error: {e}", file=sys.stderr)
            return 1

    def cmd_stats(self, detailed: bool = False) -> int:
        """Show memory system statistics."""
        try:
            import httpx

            response = httpx.get(
                f"{GATEWAY_URL}/api/memory/stats",
                timeout=10.0
            )

            if response.status_code != 200:
                print(f"‚úñ API error: {response.status_code}", file=sys.stderr)
                return 1

            stats = response.json()

            print("=== CCB Memory Statistics ===\n")
            print(f"User:           {stats.get('user_id', 'unknown')}")
            print(f"Total Sessions: {stats.get('total_sessions', 0)}")
            print(f"Total Messages: {stats.get('total_messages', 0)}")
            print(f"Total Tokens:   {stats.get('total_tokens', 0):,}")

            if detailed:
                print("\n=== Provider Statistics ===\n")
                provider_stats = stats.get("provider_stats", [])
                if provider_stats:
                    print(f"  {'Provider':<12} {'Requests':<10} {'Success':<10} {'Avg Latency':<12} {'Tokens':<10}")
                    print(f"  {'-'*12} {'-'*10} {'-'*10} {'-'*12} {'-'*10}")
                    for ps in provider_stats:
                        name = ps.get("provider", "?")
                        reqs = ps.get("total_requests", 0)
                        succ = ps.get("total_success", 0)
                        lat = ps.get("avg_latency_ms", 0)
                        tokens = ps.get("total_tokens", 0)
                        print(f"  {name:<12} {reqs:<10} {succ:<10} {lat:<12.0f} {tokens:<10}")
                else:
                    print("  (no provider data)")

                # Also fetch config
                try:
                    config_resp = httpx.get(f"{GATEWAY_URL}/api/memory/config", timeout=5.0)
                    if config_resp.status_code == 200:
                        config = config_resp.json().get("config", {})
                        print("\n=== Configuration ===\n")
                        print(f"  Enabled:        {config.get('enabled', '?')}")
                        print(f"  Auto Inject:    {config.get('auto_inject', '?')}")
                        print(f"  Max Memories:   {config.get('max_injected_memories', '?')}")
                        print(f"  Strategy:       {config.get('injection_strategy', '?')}")
                except:
                    pass

            return 0

        except ImportError:
            print("‚úñ httpx not installed. Run: pip install httpx", file=sys.stderr)
            return 1
        except Exception as e:
            print(f"‚úñ Error: {e}", file=sys.stderr)
            return 1

    def cmd_export(self, format: str = "json", output: str = None) -> int:
        """Export memory to file."""
        try:
            import httpx

            # Fetch all memory components
            export_data = {
                "exported_at": datetime.now().isoformat(),
                "stats": {},
                "observations": [],
                "sessions": [],
                "injections": []
            }

            # Fetch stats
            try:
                resp = httpx.get(f"{GATEWAY_URL}/api/memory/stats", timeout=10.0)
                if resp.status_code == 200:
                    export_data["stats"] = resp.json()
            except:
                pass

            # Fetch observations
            try:
                resp = httpx.get(f"{GATEWAY_URL}/api/memory/observations?limit=100", timeout=10.0)
                if resp.status_code == 200:
                    export_data["observations"] = resp.json().get("observations", [])
            except:
                pass

            # Fetch sessions
            try:
                resp = httpx.get(f"{GATEWAY_URL}/api/memory/sessions?limit=50", timeout=10.0)
                if resp.status_code == 200:
                    export_data["sessions"] = resp.json().get("sessions", [])
            except:
                pass

            # Fetch recent injections
            try:
                resp = httpx.get(f"{GATEWAY_URL}/api/memory/injections?limit=50", timeout=10.0)
                if resp.status_code == 200:
                    export_data["injections"] = resp.json().get("injections", [])
            except:
                pass

            # Output
            if format == "json":
                output_str = json.dumps(export_data, indent=2, ensure_ascii=False)
            else:
                # Markdown format
                lines = ["# CCB Memory Export", ""]
                lines.append(f"Exported: {export_data['exported_at']}")
                lines.append("")

                stats = export_data.get("stats", {})
                lines.append("## Statistics")
                lines.append(f"- Sessions: {stats.get('total_sessions', 0)}")
                lines.append(f"- Messages: {stats.get('total_messages', 0)}")
                lines.append(f"- Tokens: {stats.get('total_tokens', 0)}")
                lines.append("")

                if export_data.get("observations"):
                    lines.append("## Observations")
                    for obs in export_data["observations"][:20]:
                        lines.append(f"- [{obs.get('category')}] {obs.get('content', '')[:100]}")
                    lines.append("")

                output_str = "\n".join(lines)

            if output:
                Path(output).write_text(output_str, encoding='utf-8')
                print(f"‚úì Exported to: {output}")
            else:
                print(output_str)

            return 0

        except ImportError:
            print("‚úñ httpx not installed. Run: pip install httpx", file=sys.stderr)
            return 1
        except Exception as e:
            print(f"‚úñ Error: {e}", file=sys.stderr)
            return 1

    # ========================================================================
    # Phase 8: Stream Sync CLI Commands
    # ========================================================================

    def cmd_sync_streams(self, force: bool = False) -> int:
        """Sync stream files to database."""
        try:
            from memory.memory_v2 import CCBMemoryV2
            memory = CCBMemoryV2()

            print("Syncing stream files to database...")
            if force:
                print("  (force mode: re-syncing all files)")

            stats = memory.sync_all_streams(force=force)

            print(f"\n‚úì Sync completed!")
            print(f"  Synced:    {stats.get('synced', 0)} files")
            print(f"  Skipped:   {stats.get('skipped', 0)} files (already in DB)")
            print(f"  Errors:    {stats.get('errors', 0)}")
            print(f"  Entries:   {stats.get('total_entries', 0)} total")

            return 0

        except ImportError as e:
            print(f"‚úñ Memory module not available: {e}", file=sys.stderr)
            return 1
        except Exception as e:
            print(f"‚úñ Error: {e}", file=sys.stderr)
            return 1

    def cmd_stream(self, request_id: str, entry_type: str = None) -> int:
        """View stream entries from database."""
        try:
            from memory.memory_v2 import CCBMemoryV2
            memory = CCBMemoryV2()

            entries = memory.get_stream_entries(request_id, entry_type=entry_type)

            if not entries:
                print(f"No stream entries found for request: {request_id[:12]}...")
                return 0

            print(f"=== Stream Entries: {request_id[:12]}... ({len(entries)} entries) ===\n")

            for entry in entries:
                ts = entry.get('timestamp', 0)
                time_str = datetime.fromtimestamp(ts).strftime("%H:%M:%S.%f")[:-3] if ts else "?"
                etype = entry.get('entry_type', '?')
                content = entry.get('content', '')[:100]

                # Color coding by type
                type_colors = {
                    'start': '\033[34m',    # Blue
                    'status': '\033[36m',   # Cyan
                    'thinking': '\033[33m', # Yellow
                    'chunk': '\033[37m',    # White
                    'output': '\033[32m',   # Green
                    'error': '\033[31m',    # Red
                    'complete': '\033[35m', # Magenta
                }
                color = type_colors.get(etype, '\033[0m')
                reset = '\033[0m'

                print(f"  {time_str}  {color}[{etype:8}]{reset}  {content}{'...' if len(entry.get('content', '')) > 100 else ''}")

            return 0

        except ImportError as e:
            print(f"‚úñ Memory module not available: {e}", file=sys.stderr)
            return 1
        except Exception as e:
            print(f"‚úñ Error: {e}", file=sys.stderr)
            return 1

    def cmd_thinking(self, request_id: str) -> int:
        """View thinking chain for a request."""
        try:
            from memory.memory_v2 import CCBMemoryV2
            memory = CCBMemoryV2()

            thinking = memory.get_thinking_chain(request_id)

            if not thinking:
                print(f"No thinking chain found for request: {request_id[:12]}...")
                return 0

            print(f"=== Thinking Chain: {request_id[:12]}... ===\n")
            print(thinking)
            print(f"\n({len(thinking)} characters)")

            return 0

        except ImportError as e:
            print(f"‚úñ Memory module not available: {e}", file=sys.stderr)
            return 1
        except Exception as e:
            print(f"‚úñ Error: {e}", file=sys.stderr)
            return 1

    def cmd_timeline(self, request_id: str) -> int:
        """View execution timeline for a request."""
        try:
            from memory.memory_v2 import CCBMemoryV2
            memory = CCBMemoryV2()

            timeline = memory.get_request_timeline(request_id)

            if not timeline:
                print(f"No timeline found for request: {request_id[:12]}...")
                return 0

            print(f"=== Execution Timeline: {request_id[:12]}... ===\n")

            first_ts = timeline[0].get('timestamp', 0) if timeline else 0
            for entry in timeline:
                ts = entry.get('timestamp', 0)
                time_str = entry.get('time_str', '?')
                etype = entry.get('entry_type', '?')
                content = entry.get('content', '')[:80]
                delta = f"+{(ts - first_ts)*1000:.0f}ms" if first_ts else ""

                # Icons by type
                icons = {
                    'start': 'üöÄ',
                    'status': 'üìã',
                    'thinking': 'üß†',
                    'chunk': 'üìù',
                    'output': '‚úÖ',
                    'error': '‚ùå',
                    'complete': 'üèÅ',
                }
                icon = icons.get(etype, '‚Ä¢')

                print(f"  {time_str}  {delta:>10}  {icon} {etype:8}  {content}")

            return 0

        except ImportError as e:
            print(f"‚úñ Memory module not available: {e}", file=sys.stderr)
            return 1
        except Exception as e:
            print(f"‚úñ Error: {e}", file=sys.stderr)
            return 1

    # ========================================================================
    # v2.0: Heuristic Memory Commands
    # ========================================================================

    def cmd_importance(self, memory_id: str, score: float, memory_type: str = 'message') -> int:
        """Set importance score for a memory."""
        try:
            from memory.memory_v2 import CCBMemoryV2
            memory = CCBMemoryV2()

            # Validate score
            if score < 0.0 or score > 1.0:
                print(f"‚úñ Score must be between 0.0 and 1.0", file=sys.stderr)
                return 1

            success = memory.set_importance(memory_id, memory_type, score, source='user')

            if success:
                print(f"‚úì Set importance for {memory_id[:12]}... to {score:.2f}")
                return 0
            else:
                print(f"‚úñ Failed to set importance", file=sys.stderr)
                return 1

        except ImportError as e:
            print(f"‚úñ Memory module not available: {e}", file=sys.stderr)
            return 1
        except Exception as e:
            print(f"‚úñ Error: {e}", file=sys.stderr)
            return 1

    def cmd_decay(self, batch_size: int = 1000) -> int:
        """Apply time-based decay to memories."""
        try:
            from memory.memory_v2 import CCBMemoryV2
            memory = CCBMemoryV2()

            print(f"Applying decay (batch size: {batch_size})...")
            result = memory.apply_decay(batch_size=batch_size)

            print(f"\n‚úì Decay applied")
            print(f"  Updated: {result.get('updated', 0)}")
            print(f"  Flagged for forget: {result.get('flagged_for_forget', 0)}")
            return 0

        except ImportError as e:
            print(f"‚úñ Memory module not available: {e}", file=sys.stderr)
            return 1
        except Exception as e:
            print(f"‚úñ Error: {e}", file=sys.stderr)
            return 1

    def cmd_forget(self, memory_id: str, memory_type: str = 'message', reason: str = 'manual') -> int:
        """Mark a memory for forgetting."""
        try:
            from memory.memory_v2 import CCBMemoryV2
            memory = CCBMemoryV2()

            success = memory.mark_for_forgetting(memory_id, memory_type, reason=reason)

            if success:
                print(f"‚úì Marked {memory_id[:12]}... for forgetting")
                print(f"  Run 'ccb-consolidate forget' to clean up")
                return 0
            else:
                print(f"‚úñ Failed to mark for forgetting", file=sys.stderr)
                return 1

        except ImportError as e:
            print(f"‚úñ Memory module not available: {e}", file=sys.stderr)
            return 1
        except Exception as e:
            print(f"‚úñ Error: {e}", file=sys.stderr)
            return 1

    def cmd_search_scored(self, query: str, limit: int = 10, verbose: bool = False) -> int:
        """Search memories with heuristic scores (R/I/T)."""
        try:
            from memory.memory_v2 import CCBMemoryV2
            memory = CCBMemoryV2()

            print(f"Searching for: {query}\n")
            results = memory.search_with_scores(query, limit=limit)

            if not results:
                print("No results found")
                return 0

            print(f"=== Results ({len(results)} matches) ===\n")
            print(f"  {'#':<3} {'Final':>6} {'R':>5} {'I':>5} {'T':>5}  {'Provider':<10} Content")
            print(f"  {'-'*3} {'-'*6} {'-'*5} {'-'*5} {'-'*5}  {'-'*10} {'-'*40}")

            for i, result in enumerate(results, 1):
                final = result.get('final_score', 0)
                rel = result.get('relevance_score', 0)
                imp = result.get('importance_score', 0)
                rec = result.get('recency_score', 0)
                provider = result.get('provider', '?')[:10]
                content = result.get('content', '')[:40]

                print(f"  {i:<3} {final:>6.3f} {rel:>5.2f} {imp:>5.2f} {rec:>5.2f}  {provider:<10} {content}...")

                if verbose:
                    print(f"      ID: {result.get('message_id', '?')[:36]}")
                    print(f"      Access: {result.get('access_count', 0)} times, Last: {result.get('last_accessed_at', 'never')}")
                    print()

            print(f"\n  R=Relevance, I=Importance, T=Recency (Time)")
            print(f"  Formula: Final = 0.4R + 0.3I + 0.3T")
            return 0

        except ImportError as e:
            print(f"‚úñ Memory module not available: {e}", file=sys.stderr)
            return 1
        except Exception as e:
            print(f"‚úñ Error: {e}", file=sys.stderr)
            return 1

    def cmd_stats_v2(self) -> int:
        """Show extended statistics including heuristic system metrics."""
        try:
            from memory.memory_v2 import CCBMemoryV2
            memory = CCBMemoryV2()

            stats = memory.get_memory_stats_v2()

            print("=== CCB Memory Statistics (v2.0) ===\n")

            # Basic stats
            print(f"User:           {stats.get('user_id', 'unknown')}")
            print(f"Total Sessions: {stats.get('total_sessions', 0)}")
            print(f"Total Messages: {stats.get('total_messages', 0)}")
            print(f"Total Tokens:   {stats.get('total_tokens', 0):,}")

            # Heuristic stats
            heuristic = stats.get('heuristic', {})
            if heuristic:
                print(f"\n=== Heuristic System ===\n")
                print(f"Tracked Memories:   {heuristic.get('tracked_memories', 0)}")
                print(f"Total Accesses:     {heuristic.get('total_accesses', 0)}")
                print(f"Accesses (24h):     {heuristic.get('accesses_24h', 0)}")
                print(f"Consolidations:     {heuristic.get('total_consolidations', 0)}")

                dist = heuristic.get('importance_distribution', {})
                if dist:
                    print(f"\nImportance Distribution:")
                    print(f"  High (‚â•0.8):   {dist.get('high', 0)}")
                    print(f"  Medium:        {dist.get('medium', 0)}")
                    print(f"  Low (<0.5):    {dist.get('low', 0)}")

            return 0

        except ImportError as e:
            print(f"‚úñ Memory module not available: {e}", file=sys.stderr)
            return 1
        except Exception as e:
            print(f"‚úñ Error: {e}", file=sys.stderr)
            return 1


def main():
    parser = argparse.ArgumentParser(
        description="CCB Memory System CLI",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  ccb-mem save                     # Save current session
  ccb-mem save ~/path/to/session.jsonl
  ccb-mem consolidate              # Consolidate last 24 hours
  ccb-mem consolidate --hours 48   # Consolidate last 48 hours
  ccb-mem consolidate --llm        # Use LLM for enhanced consolidation
  ccb-mem search "gateway"         # Search for keyword
  ccb-mem show today               # Show today's memory
  ccb-mem show 2026-02-05          # Show specific date
  ccb-mem inject yesterday         # Get path for @ injection
  ccb-mem list                     # List recent files

Phase 7 Commands:
  ccb-mem trace <request_id>       # Trace injection details
  ccb-mem injections               # Show recent injections
  ccb-mem injections --limit 20    # Show more injections
  ccb-mem stats                    # Show basic statistics
  ccb-mem stats --detailed         # Show detailed statistics
  ccb-mem export                   # Export memory as JSON
  ccb-mem export --format md       # Export as Markdown
  ccb-mem export -o memory.json    # Export to file

Phase 8 Commands:
  ccb-mem sync-streams             # Sync stream files to database
  ccb-mem sync-streams --force     # Force re-sync all files
  ccb-mem stream <request_id>      # View stream entries from DB
  ccb-mem thinking <request_id>    # View thinking chain
  ccb-mem timeline <request_id>    # View execution timeline

v2.0 Heuristic Commands:
  ccb-mem importance <id> <score>  # Set importance (0.0-1.0)
  ccb-mem decay                    # Apply time-based decay
  ccb-mem forget <id>              # Mark memory for forgetting
  ccb-mem search-scored <query>    # Search with R/I/T scores
  ccb-mem stats-v2                 # Show heuristic stats
"""
    )

    subparsers = parser.add_subparsers(dest='command', help='Available commands')

    # save command
    save_parser = subparsers.add_parser('save', help='Save session to archive')
    save_parser.add_argument('session_path', nargs='?', help='Path to session.jsonl')
    save_parser.add_argument('--force', '-f', action='store_true', help='Save even trivial sessions')

    # consolidate command
    consolidate_parser = subparsers.add_parser('consolidate', help='Consolidate to long-term memory')
    consolidate_parser.add_argument('--hours', '-H', type=int, default=24, help='Hours to look back')
    consolidate_parser.add_argument('--llm', action='store_true', help='Use LLM for enhanced consolidation')
    consolidate_parser.add_argument('--llm-provider', type=str, default='kimi', help='LLM provider')
    consolidate_parser.add_argument('--dry-run', action='store_true', help='Run without saving')

    # search command
    search_parser = subparsers.add_parser('search', help='Search archives')
    search_parser.add_argument('keyword', help='Keyword to search for')

    # show command
    show_parser = subparsers.add_parser('show', help='Show memory for date')
    show_parser.add_argument('date', help='Date (YYYY-MM-DD, today, yesterday)')

    # inject command
    inject_parser = subparsers.add_parser('inject', help='Get path for @ injection')
    inject_parser.add_argument('date', help='Date (YYYY-MM-DD, today, yesterday)')

    # list command
    list_parser = subparsers.add_parser('list', help='List recent files')
    list_parser.add_argument('--limit', '-n', type=int, default=10, help='Max items to show')

    # Phase 7: New commands
    # trace command
    trace_parser = subparsers.add_parser('trace', help='Trace injection details for a request')
    trace_parser.add_argument('request_id', help='Request ID to trace')

    # injections command
    injections_parser = subparsers.add_parser('injections', help='Show recent memory injections')
    injections_parser.add_argument('--limit', '-n', type=int, default=10, help='Max items to show')
    injections_parser.add_argument('--session', '-s', type=str, help='Filter by session ID')

    # stats command
    stats_parser = subparsers.add_parser('stats', help='Show memory system statistics')
    stats_parser.add_argument('--detailed', '-d', action='store_true', help='Show detailed stats')

    # export command
    export_parser = subparsers.add_parser('export', help='Export memory to file')
    export_parser.add_argument('--format', '-f', choices=['json', 'md'], default='json', help='Export format')
    export_parser.add_argument('--output', '-o', type=str, help='Output file path')

    # Phase 8: Stream sync commands
    # sync-streams command
    sync_streams_parser = subparsers.add_parser('sync-streams', help='Sync stream files to database')
    sync_streams_parser.add_argument('--force', '-f', action='store_true', help='Force re-sync all files')

    # stream command
    stream_parser = subparsers.add_parser('stream', help='View stream entries from database')
    stream_parser.add_argument('request_id', help='Request ID')
    stream_parser.add_argument('--type', '-t', type=str, help='Filter by entry type')

    # thinking command
    thinking_parser = subparsers.add_parser('thinking', help='View thinking chain for a request')
    thinking_parser.add_argument('request_id', help='Request ID')

    # timeline command
    timeline_parser = subparsers.add_parser('timeline', help='View execution timeline for a request')
    timeline_parser.add_argument('request_id', help='Request ID')

    # v2.0: Heuristic commands
    # importance command
    importance_parser = subparsers.add_parser('importance', help='Set importance score for a memory')
    importance_parser.add_argument('memory_id', help='Memory ID (message_id or observation_id)')
    importance_parser.add_argument('score', type=float, help='Importance score (0.0-1.0)')
    importance_parser.add_argument('--type', '-t', choices=['message', 'observation'], default='message', help='Memory type')

    # decay command
    decay_parser = subparsers.add_parser('decay', help='Apply time-based decay to memories')
    decay_parser.add_argument('--batch-size', '-b', type=int, default=1000, help='Batch size')

    # forget command
    forget_parser = subparsers.add_parser('forget', help='Mark memory for forgetting')
    forget_parser.add_argument('memory_id', help='Memory ID to forget')
    forget_parser.add_argument('--type', '-t', choices=['message', 'observation'], default='message', help='Memory type')
    forget_parser.add_argument('--reason', '-r', type=str, default='manual', help='Reason for forgetting')

    # search-scored command
    search_scored_parser = subparsers.add_parser('search-scored', help='Search with heuristic R/I/T scores')
    search_scored_parser.add_argument('query', help='Search query')
    search_scored_parser.add_argument('--limit', '-n', type=int, default=10, help='Max results')
    search_scored_parser.add_argument('--verbose', '-v', action='store_true', help='Show more details')

    # stats-v2 command
    stats_v2_parser = subparsers.add_parser('stats-v2', help='Show extended v2.0 statistics')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 0

    cli = CCBMemoryCLI()

    if args.command == 'save':
        return cli.cmd_save(args.session_path, args.force)
    elif args.command == 'consolidate':
        return cli.cmd_consolidate(args.hours, args.llm, args.llm_provider, args.dry_run)
    elif args.command == 'search':
        return cli.cmd_search(args.keyword)
    elif args.command == 'show':
        return cli.cmd_show(args.date)
    elif args.command == 'inject':
        return cli.cmd_inject(args.date)
    elif args.command == 'list':
        return cli.cmd_list(args.limit)
    # Phase 7 commands
    elif args.command == 'trace':
        return cli.cmd_trace(args.request_id)
    elif args.command == 'injections':
        return cli.cmd_injections(args.limit, args.session)
    elif args.command == 'stats':
        return cli.cmd_stats(args.detailed)
    elif args.command == 'export':
        return cli.cmd_export(args.format, args.output)
    # Phase 8 commands
    elif args.command == 'sync-streams':
        return cli.cmd_sync_streams(args.force)
    elif args.command == 'stream':
        return cli.cmd_stream(args.request_id, args.type)
    elif args.command == 'thinking':
        return cli.cmd_thinking(args.request_id)
    elif args.command == 'timeline':
        return cli.cmd_timeline(args.request_id)
    # v2.0: Heuristic commands
    elif args.command == 'importance':
        return cli.cmd_importance(args.memory_id, args.score, args.type)
    elif args.command == 'decay':
        return cli.cmd_decay(args.batch_size)
    elif args.command == 'forget':
        return cli.cmd_forget(args.memory_id, args.type, args.reason)
    elif args.command == 'search-scored':
        return cli.cmd_search_scored(args.query, args.limit, args.verbose)
    elif args.command == 'stats-v2':
        return cli.cmd_stats_v2()
    else:
        parser.print_help()
        return 1


if __name__ == "__main__":
    sys.exit(main())
